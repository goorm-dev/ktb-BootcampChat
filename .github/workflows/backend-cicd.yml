# 백엔드 API CI/CD 파이프라인 
# AMI 빌드 및 Auto Scaling Group 자동 배포
name: Backend API CI/CD

on:
  push:
    branches: [ jacky ]
    paths:
      - 'backend/**'
      - 'scripts/**'
      - '.github/workflows/backend-cicd.yml'
  pull_request:
    branches: [ jacky ]
    paths:
      - 'backend/**'

# 환경 변수 설정
env:
  AWS_REGION: ap-northeast-2
  BASE_AMI_ID: ami-0f5e205427609c732  # Amazon Linux 2023 최신 AMI ID 
  INSTANCE_TYPE: t3.small
  # 네트워크 설정
  VPC_ID: vpc-0cbb28aa7ecfee012
  SUBNET_ID: subnet-054215bf6c92eb539
  # GitHub 레포지토리 설정
  GITHUB_REPO: https://github.com/100-hours-a-week/8-ktb-chat.git
  GITHUB_BRANCH: jacky
  # ASG 관련 설정 - 사용자 요청에 따라 변경
  LAUNCH_TEMPLATE_NAME: pumati-load-test-backend-20250724073402992900000003
  ASG_NAME: pumati-load-test-backend-asg

jobs:
  # AMI 빌드 및 ASG 자동 배포
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: 코드 체크아웃
      uses: actions/checkout@v4
      
    - name: AWS 자격증명 설정
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: 빌드 메타데이터 생성
      id: meta
      run: |
        # Git 커밋 해시의 짧은 버전 생성
        SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
        
        # 타임스탬프 생성
        TIMESTAMP=$(date +%Y%m%d-%H%M%S)
        
        # AMI 이름 생성
        AMI_NAME="ktb-chat-backend-jacky-${TIMESTAMP}-${SHORT_SHA}"
        
        echo "ami_name=${AMI_NAME}" >> $GITHUB_OUTPUT
        echo "short_sha=${SHORT_SHA}" >> $GITHUB_OUTPUT
        echo "timestamp=${TIMESTAMP}" >> $GITHUB_OUTPUT

    - name: AMI 설정 스크립트 생성
      run: |
        echo "📝 AMI 설정을 위한 User Data 스크립트 생성..."
        
        cat > ami-setup.sh << EOF
        #!/bin/bash
        
        # 로그 설정
        exec > >(tee /var/log/ami-setup.log) 2>&1
        echo "=== AMI 설정 시작: $(date) ==="
        
        # 시스템 업데이트
        echo "시스템 업데이트 중..."
        yum update -y
        
        # 개발 도구 설치
        echo "개발 도구 설치 중..."
        yum groupinstall -y "Development Tools"
        yum install -y git curl unzip
        
        # Node.js 18 설치
        echo "Node.js 18 설치 중..."
        curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -
        yum install -y nodejs
        
        # PM2 전역 설치
        echo "PM2 설치 중..."
        npm install -g pm2
        
        # 애플리케이션 사용자 생성
        echo "애플리케이션 사용자 생성..."
        useradd -m -s /bin/bash appuser
        
        # 애플리케이션 디렉토리 생성
        echo "애플리케이션 디렉토리 설정..."
        mkdir -p /opt/ktb-chat-backend
        chown appuser:appuser /opt/ktb-chat-backend
        
        # GitHub에서 코드 클론
        echo "GitHub에서 백엔드 코드 클론 중..."
        cd /opt/ktb-chat-backend
        git clone -b ${{ env.GITHUB_BRANCH }} ${{ env.GITHUB_REPO }} .
        
        # 백엔드 디렉토리로 이동 및 의존성 설치 (최적화)
        cd backend
        echo "백엔드 의존성 설치 중... (병렬 설치 및 캐시 활용)"
        # 병렬 설치 및 캐시 최적화로 속도 향상
        npm ci --production --silent --prefer-offline --no-audit &
        
        # 백그라운드에서 의존성 설치하는 동안 다른 설정 작업 진행
        cd ..
        
        # 로그 로테이션 설정 (의존성 설치와 병렬 진행)
        cat > /etc/logrotate.d/ktb-chat-backend << 'EOFLOGROTATE'
        /var/log/ktb-chat-backend*.log {
            daily
            rotate 30
            compress
            delaycompress
            missingok
            notifempty
            create 644 appuser appuser
            postrotate
                /usr/bin/pm2 reloadLogs
            endscript
        }
        EOFLOGROTATE
        
        # CloudWatch 에이전트 설치 (병렬)
        echo "CloudWatch 에이전트 설치..."
        yum install -y amazon-cloudwatch-agent &
        
        # 헬스체크 엔드포인트 확인 스크립트 생성
        cat > /usr/local/bin/health-check.sh << 'EOFHEALTH'
        #!/bin/bash
        # 백엔드 애플리케이션 헬스체크
        curl -f http://localhost:5001/health || exit 1
        EOFHEALTH
        chmod +x /usr/local/bin/health-check.sh
        
        # 의존성 설치 완료 대기
        cd backend
        wait  # npm ci 완료 대기
        
        # 소유권 변경 및 PM2 디렉토리 설정
        chown -R appuser:appuser /opt/ktb-chat-backend
        
        # PM2 홈 디렉토리 생성 및 권한 설정
        mkdir -p /opt/ktb-chat-backend/.pm2
        chown -R appuser:appuser /opt/ktb-chat-backend/.pm2
        
        # 로그 디렉토리 권한 설정
        mkdir -p /var/log
        touch /var/log/ktb-chat-backend.log
        touch /var/log/ktb-chat-backend-out.log  
        touch /var/log/ktb-chat-backend-error.log
        chown appuser:appuser /var/log/ktb-chat-backend*.log
        
        # GitHub Secrets에서 환경 변수 파일 생성
        cat > .env << 'EOFENV'
        ${{ secrets.ENV_BACKEND_DEV }}
        EOFENV
        
        # PM2 ecosystem 파일 생성 (user/uid/gid 설정 제거)
        cat > ecosystem.config.js << 'EOFPM2'
        module.exports = {
          apps: [{
            name: 'ktb-chat-backend',
            script: 'server.js',
            cwd: '/opt/ktb-chat-backend/backend',
            instances: 1,
            exec_mode: 'fork',
            watch: false,
            max_memory_restart: '1G',
            env: {
              NODE_ENV: 'production',
              PORT: 5001
            },
            log_file: '/var/log/ktb-chat-backend.log',
            out_file: '/var/log/ktb-chat-backend-out.log',
            error_file: '/var/log/ktb-chat-backend-error.log',
            merge_logs: true,
            time: true,
            // user, uid, gid 설정 제거 - PM2가 이미 appuser로 실행됨
          }]
        };
        EOFPM2
        
        # systemd 서비스 파일 생성 (PM2 ecosystem 파일 사용)
        cat > /etc/systemd/system/ktb-chat-backend.service << 'EOFSYSTEMD'
        [Unit]
        Description=KTB Chat Backend Application
        After=network.target
        
        [Service]
        Type=simple
        User=appuser
        Group=appuser
        WorkingDirectory=/opt/ktb-chat-backend/backend
        # ecosystem.config.js 파일 사용으로 user 권한 문제 해결
        ExecStart=/usr/bin/pm2 start ecosystem.config.js --no-daemon
        ExecReload=/usr/bin/pm2 reload ecosystem.config.js
        ExecStop=/usr/bin/pm2 stop ecosystem.config.js
        Restart=always
        RestartSec=10
        StandardOutput=syslog
        StandardError=syslog
        SyslogIdentifier=ktb-chat-backend
        # 환경 변수 설정
        Environment=NODE_ENV=production
        Environment=PM2_HOME=/opt/ktb-chat-backend/.pm2
        
        [Install]
        WantedBy=multi-user.target
        EOFSYSTEMD
        
        # systemd 서비스 활성화 (부팅 시 자동 시작)
        systemctl daemon-reload
        systemctl enable ktb-chat-backend.service
        
        # 백그라운드 작업들 완료 대기
        wait  # 모든 백그라운드 작업 완료 대기
        
        # API 서버 AMI 설정 완료 표시
        echo "=== API 서버 AMI 설정 완료: $(date) ==="
        echo "GitHub 레포지토리: ${{ env.GITHUB_REPO }}"
        echo "브랜치: ${{ env.GITHUB_BRANCH }}"
        echo "커밋: ${{ github.sha }}"
        
        # 시스템 준비 완료 신호
        touch /tmp/ami-setup-complete
        EOF
        
        # 스크립트 권한 설정
        chmod +x ami-setup.sh

    - name: 기본 보안 그룹 확인
      id: security-group
      run: |
        echo "🔒 VPC 기본 보안 그룹 사용..."
        
        # VPC의 기본 보안 그룹 찾기
        DEFAULT_SG_ID=$(aws ec2 describe-security-groups \
          --filters "Name=group-name,Values=default" "Name=vpc-id,Values=${{ env.VPC_ID }}" \
          --query 'SecurityGroups[0].GroupId' \
          --output text)
        
        if [[ "$DEFAULT_SG_ID" == "None" || "$DEFAULT_SG_ID" == "" ]]; then
          echo "❌ VPC 기본 보안 그룹을 찾을 수 없습니다."
          exit 1
        fi
        
        echo "✅ VPC 기본 보안 그룹 사용: ${DEFAULT_SG_ID}"
        echo "ℹ️ 기본 보안 그룹이므로 별도 정리 불필요"
        
        # 기본 보안 그룹에 필요한 아웃바운드 규칙이 있는지 확인 (보통 기본값으로 모든 아웃바운드 허용)
        echo "📋 보안 그룹 규칙 확인 중..."
        aws ec2 describe-security-groups --group-ids ${DEFAULT_SG_ID} --query 'SecurityGroups[0].{Inbound:IpPermissions,Outbound:IpPermissionsEgress}'
        
        echo "security_group_id=${DEFAULT_SG_ID}" >> $GITHUB_OUTPUT

    - name: EC2 인스턴스 생성 및 AMI 빌드
      id: create-instance
      run: |
        echo "🖥️ AMI 빌드용 EC2 인스턴스 생성 중..."
        
        # EC2 인스턴스 실행 (VPC 및 서브넷 지정)
        INSTANCE_ID=$(aws ec2 run-instances \
          --image-id ${{ env.BASE_AMI_ID }} \
          --instance-type ${{ env.INSTANCE_TYPE }} \
          --subnet-id ${{ env.SUBNET_ID }} \
          --security-group-ids ${{ steps.security-group.outputs.security_group_id }} \
          --associate-public-ip-address \
          --user-data file://ami-setup.sh \
          --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=AMI-Build-${{ steps.meta.outputs.ami_name }}},{Key=Purpose,Value=AMI-Build},{Key=Application,Value=ktb-chat-backend}]' \
          --query 'Instances[0].InstanceId' \
          --output text)
        
        echo "instance_id=${INSTANCE_ID}" >> $GITHUB_OUTPUT
        echo "✅ 인스턴스 생성됨: ${INSTANCE_ID}"
        
        # 인스턴스가 실행될 때까지 대기
        echo "⏳ 인스턴스 부팅 및 설정 대기 중..."
        aws ec2 wait instance-running --instance-ids ${INSTANCE_ID}
        
        # 최적화된 대기 시간 (병렬 설치로 시간 단축)
        echo "📦 백엔드 애플리케이션 설치 중... (약 3분 소요)"
        sleep 180
        
        echo "✅ 인스턴스 설정 완료"

    - name: AMI 생성
      id: create-ami
      run: |
        echo "📸 AMI 생성 중..."
        
        # 인스턴스 중지
        echo "인스턴스 중지 중..."
        aws ec2 stop-instances --instance-ids ${{ steps.create-instance.outputs.instance_id }}
        aws ec2 wait instance-stopped --instance-ids ${{ steps.create-instance.outputs.instance_id }}
        
        # AMI 생성
        echo "AMI 스냅샷 생성 중..."
        AMI_ID=$(aws ec2 create-image \
          --instance-id ${{ steps.create-instance.outputs.instance_id }} \
          --name "${{ steps.meta.outputs.ami_name }}" \
          --description "KTB Chat Backend API AMI - jacky branch - Built on $(date)" \
          --no-reboot \
          --tag-specifications 'ResourceType=image,Tags=[{Key=Name,Value=${{ steps.meta.outputs.ami_name }}},{Key=Branch,Value=jacky},{Key=Application,Value=ktb-chat-backend},{Key=Environment,Value=development},{Key=BuildTimestamp,Value=${{ steps.meta.outputs.timestamp }}}]' \
          --query 'ImageId' \
          --output text)
        
        echo "ami_id=${AMI_ID}" >> $GITHUB_OUTPUT
        echo "✅ AMI 생성됨: ${AMI_ID}"
        
        # AMI 사용 가능할 때까지 대기
        echo "⏳ AMI 생성 완료 대기 중..."
        aws ec2 wait image-available --image-ids ${AMI_ID}
        
        echo "🎉 AMI 생성 완료: ${AMI_ID}"

    - name: Launch Template 업데이트
      id: update-template
      run: |
        echo "🚀 Launch Template 업데이트 중..."
        
        # 기존 Launch Template 확인
        if aws ec2 describe-launch-templates --launch-template-names ${{ env.LAUNCH_TEMPLATE_NAME }} >/dev/null 2>&1; then
          echo "기존 Launch Template 발견: ${{ env.LAUNCH_TEMPLATE_NAME }}"
          
          # 기존 템플릿의 최신 버전 정보 가져오기
          echo "기존 템플릿 설정 정보 가져오는 중..."
          EXISTING_CONFIG=$(aws ec2 describe-launch-template-versions \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --versions '$Latest' \
            --query 'LaunchTemplateVersions[0].LaunchTemplateData' \
            --output json)
          
          # 기존 설정에서 AMI ID만 업데이트
          echo "기존 설정을 유지하면서 AMI ID만 업데이트..."
          UPDATED_CONFIG=$(echo "$EXISTING_CONFIG" | jq --arg ami_id "${{ steps.create-ami.outputs.ami_id }}" '.ImageId = $ami_id')
          
          # 새 버전 생성 (기존 설정 + 새 AMI ID)
          NEW_VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --source-version '$Latest' \
            --launch-template-data "$UPDATED_CONFIG" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          
          echo "template_version=${NEW_VERSION}" >> $GITHUB_OUTPUT
          echo "✅ Launch Template 새 버전 생성됨: ${NEW_VERSION} (AMI ID만 업데이트)"
          
          # 기본 버전으로 설정
          aws ec2 modify-launch-template \
            --launch-template-name ${{ env.LAUNCH_TEMPLATE_NAME }} \
            --default-version ${NEW_VERSION}
          
          echo "✅ Launch Template 기본 버전 업데이트 완료"
          echo "ℹ️ 기존 템플릿의 모든 설정이 유지되었습니다 (AMI ID 제외)"
          
        else
          echo "❌ Launch Template이 존재하지 않습니다: ${{ env.LAUNCH_TEMPLATE_NAME }}"
          echo "템플릿이 존재하지 않으므로 워크플로우를 중단합니다."
          echo "먼저 AWS 콘솔에서 해당 템플릿을 생성하거나 템플릿 이름을 확인해주세요."
          exit 1
        fi

    - name: Auto Scaling Group 업데이트 및 인스턴스 새로고침
      id: update-asg
      run: |
        echo "📈 Auto Scaling Group 업데이트 및 인스턴스 교체 중..."
        
        # ASG 존재 확인
        if aws autoscaling describe-auto-scaling-groups --auto-scaling-group-names ${{ env.ASG_NAME }} >/dev/null 2>&1; then
          echo "기존 ASG 발견: ${{ env.ASG_NAME }}"
          
          # ASG Launch Template 업데이트
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name ${{ env.ASG_NAME }} \
            --launch-template LaunchTemplateName=${{ env.LAUNCH_TEMPLATE_NAME }},Version='$Latest'
          
          echo "✅ ASG Launch Template 업데이트 완료"
          
          # 인스턴스 새로고침 시작
          echo "🔄 인스턴스 새로고침 시작 중..."
          REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name ${{ env.ASG_NAME }} \
            --preferences '{
              "InstanceWarmup": 300,
              "MinHealthyPercentage": 50,
              "CheckpointPercentages": [50, 100],
              "CheckpointDelay": 600,
              "SkipMatching": false
            }' \
            --query 'InstanceRefreshId' \
            --output text)
          
          echo "refresh_id=${REFRESH_ID}" >> $GITHUB_OUTPUT
          echo "✅ 인스턴스 새로고침 시작됨: ${REFRESH_ID}"
          
          # 새로고침 진행 상황 모니터링
          echo "⏳ 인스턴스 새로고침 진행 상황 모니터링 중..."
          
          while true; do
            # 새로고침 상태 확인
            REFRESH_STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name ${{ env.ASG_NAME }} \
              --instance-refresh-ids ${REFRESH_ID} \
              --query 'InstanceRefreshes[0].Status' \
              --output text)
            
            # 진행률 확인
            PERCENTAGE=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name ${{ env.ASG_NAME }} \
              --instance-refresh-ids ${REFRESH_ID} \
              --query 'InstanceRefreshes[0].PercentageComplete' \
              --output text)
            
            echo "현재 상태: ${REFRESH_STATUS}, 진행률: ${PERCENTAGE}%"
            
            # 완료 상태 확인
            if [[ "$REFRESH_STATUS" == "Successful" ]]; then
              echo "🎉 인스턴스 새로고침 성공적으로 완료!"
              break
            elif [[ "$REFRESH_STATUS" == "Failed" || "$REFRESH_STATUS" == "Cancelled" ]]; then
              echo "❌ 인스턴스 새로고침 실패: ${REFRESH_STATUS}"
              
              # 실패 원인 조회
              FAILURE_REASON=$(aws autoscaling describe-instance-refreshes \
                --auto-scaling-group-name ${{ env.ASG_NAME }} \
                --instance-refresh-ids ${REFRESH_ID} \
                --query 'InstanceRefreshes[0].StatusReason' \
                --output text)
              
              echo "실패 원인: ${FAILURE_REASON}"
              exit 1
            elif [[ "$REFRESH_STATUS" == "InProgress" ]]; then
              echo "계속 진행 중... 30초 후 다시 확인합니다."
              sleep 30
            else
              echo "알 수 없는 상태: ${REFRESH_STATUS}"
              sleep 30
            fi
          done
          
        else
          echo "❌ ASG가 존재하지 않습니다: ${{ env.ASG_NAME }}"
          echo "템플릿은 업데이트되었지만 ASG가 없으므로 인스턴스 새로고침을 진행할 수 없습니다."
          echo "AWS 콘솔에서 ASG를 확인해주세요."
          exit 1
        fi

    - name: 인스턴스 정리
      if: always()
      run: |
        echo "🧹 빌드용 인스턴스 정리 중..."
        
        if [[ -n "${{ steps.create-instance.outputs.instance_id }}" ]]; then
          # 인스턴스 종료
          aws ec2 terminate-instances --instance-ids ${{ steps.create-instance.outputs.instance_id }}
          echo "✅ 인스턴스 종료됨: ${{ steps.create-instance.outputs.instance_id }}"
        fi
        
        # 임시 파일 정리
        rm -f ami-setup.sh

    - name: 배포 결과 요약
      if: success()
      run: |
        echo "## 🎉 백엔드 API CI/CD 완료" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📋 AMI 정보" >> $GITHUB_STEP_SUMMARY
        echo "- **AMI ID**: \`${{ steps.create-ami.outputs.ami_id }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **AMI 이름**: \`${{ steps.meta.outputs.ami_name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- **커밋**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **브랜치**: jacky" >> $GITHUB_STEP_SUMMARY
        echo "- **빌드 시간**: ${{ steps.meta.outputs.timestamp }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🔧 빌드 환경 설정" >> $GITHUB_STEP_SUMMARY
        echo "- **GitHub 레포**: ${{ env.GITHUB_REPO }}" >> $GITHUB_STEP_SUMMARY
        echo "- **브랜치**: ${{ env.GITHUB_BRANCH }}" >> $GITHUB_STEP_SUMMARY
        echo "- **배포 대상**: Load Test 환경" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 🚀 배포 정보" >> $GITHUB_STEP_SUMMARY
        echo "- **Launch Template**: \`${{ env.LAUNCH_TEMPLATE_NAME }}\` (버전 ${{ steps.update-template.outputs.template_version }})" >> $GITHUB_STEP_SUMMARY
        echo "- **Auto Scaling Group**: \`${{ env.ASG_NAME }}\` (인스턴스 새로고침 완료)" >> $GITHUB_STEP_SUMMARY
        echo "- **인스턴스 새로고침 ID**: \`${{ steps.update-asg.outputs.refresh_id }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### 📊 모니터링" >> $GITHUB_STEP_SUMMARY
        echo "- 애플리케이션 포트: 5001" >> $GITHUB_STEP_SUMMARY
        echo "- 헬스체크: \`/health\` 엔드포인트" >> $GITHUB_STEP_SUMMARY
        echo "- 로그 위치: \`/var/log/ktb-chat-backend*.log\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ⚠️ 배포 주의사항" >> $GITHUB_STEP_SUMMARY
        echo "- 모든 기존 인스턴스가 새 AMI로 교체되었습니다" >> $GITHUB_STEP_SUMMARY
        echo "- 인스턴스 새로고침 중 서비스 가용성이 50% 이상 유지되었습니다" >> $GITHUB_STEP_SUMMARY
        echo "- 새 인스턴스는 5분의 워밍업 시간을 거쳤습니다" >> $GITHUB_STEP_SUMMARY
        echo "- MongoDB, Redis 연결을 확인해주세요" >> $GITHUB_STEP_SUMMARY
